import requests
import pandas as pd
import sqlite3
from sqlalchemy import create_engine

# Configuration
API_KEY = "YOUR_CENSUS_API_KEY"
BASE_URL = "https://api.census.gov/data"
YEAR = "2020"
DATASET = "acs/acs5"  # Adjust based on the specific dataset you need
SQLITE_DB = "census_data.db"  # Name of the SQLite database file

# List of tables to fetch (adjust based on your needs)
TABLES = ["PCT1", "PCT2", "PCT3", "PCT4", "PCT10", "PCT12", "PCT19", "P9", "P11", "H11", "HCT1", "HCT3"]

def fetch_census_data(table):
    url = f"{BASE_URL}/{YEAR}/{DATASET}"
    params = {
        "get": f"group({table})",
        "for": "tract:*",
        "in": "state:*",
        "key": API_KEY
    }
    response = requests.get(url, params=params)
    if response.status_code == 200:
        data = response.json()
        df = pd.DataFrame(data[1:], columns=data[0])
        return df
    else:
        print(f"Error fetching data for table {table}: {response.status_code}")
        return None

def create_table(conn, table_name, df):
    # Create a table based on the DataFrame structure
    columns = [f"{col} TEXT" for col in df.columns]
    create_table_sql = f"CREATE TABLE IF NOT EXISTS {table_name} ({', '.join(columns)})"
    conn.execute(create_table_sql)

def main():
    # Create SQLite database and connection
    engine = create_engine(f"sqlite:///{SQLITE_DB}")
    conn = sqlite3.connect(SQLITE_DB)

    for table in TABLES:
        print(f"Fetching data for table {table}...")
        df = fetch_census_data(table)
        
        if df is not None:
            print(f"Creating table and uploading data for {table} to SQLite...")
            table_name = table.lower()
            create_table(conn, table_name, df)
            
            # Use to_sql to insert the data 707ce89056798d5cb2db9258299ca23cb8d0f7ca
            df.to_sql(table_name, engine, if_exists='replace', index=False)
            print(f"Table {table} created and data uploaded successfully.")
        
    conn.close()
    print("Data fetching and uploading to SQLite complete.")

if __name__ == "__main__":
    main()




*********************************************************

import requests
import json

# Configuration
API_KEY = "YOUR_CENSUS_API_KEY"
BASE_URL = "https://api.census.gov/data"
YEAR = "2020"
DATASET = "dec/pl"

def get_available_tables():
    url = f"{BASE_URL}/{YEAR}/{DATASET}/variables.json"
    params = {
        "key": API_KEY
    }
    
    try:
        response = requests.get(url, params=params)
        response.raise_for_status()  # Raises an HTTPError for bad responses
        
        data = response.json()
        variables = data['variables']
        
        # Extract unique table identifiers
        tables = set()
        for var in variables:
            if '_' in var:
                table = var.split('_')[0]
                tables.add(table)
        
        return sorted(list(tables))
    
    except requests.exceptions.RequestException as e:
        print(f"An error occurred: {e}")
        return None

def main():
    print("Fetching available tables for the 2020 Decennial Census Public Law dataset...")
    tables = get_available_tables()
    
    if tables:
        print("\nAvailable tables:")
        for table in tables:
            print(f"- {table}")
        print(f"\nTotal number of tables: {len(tables)}")
    else:
        print("Failed to retrieve table information.")

if __name__ == "__main__":
    main()


*******************************************************************************

import requests
import pandas as pd
import sqlite3
from sqlalchemy import create_engine
import time

# Configuration
API_KEY = "YOUR_CENSUS_API_KEY"
BASE_URL = "https://api.census.gov/data"
YEAR = "2020"
DATASET = "dec/pl"
SQLITE_DB = "census_data.db"

# Updated list of tables and their variables
TABLES = {
    "P1": ["P1_001N"],  # Total Population
    "H1": ["H1_001N"],  # Total Housing Units
}

def fetch_census_data(table, variables):
    url = f"{BASE_URL}/{YEAR}/{DATASET}"
    params = {
        "get": ",".join(variables + ["NAME"]),
        "for": "state:*",  # Changed to state level
        "key": API_KEY
    }
    
    for attempt in range(3):  # Try up to 3 times
        try:
            response = requests.get(url, params=params)
            response.raise_for_status()  # Raises an HTTPError for bad responses
            data = response.json()
            df = pd.DataFrame(data[1:], columns=data[0])
            return df
        except requests.exceptions.RequestException as e:
            print(f"Error fetching data for table {table} (Attempt {attempt + 1}): {e}")
            print(f"URL: {response.url}")
            print(f"Response content: {response.text}")
            if attempt < 2:
                print("Retrying in 5 seconds...")
                time.sleep(5)
            else:
                print("Max retries reached. Moving to next table.")
                return None

def create_table(conn, table_name, df):
    columns = [f"{col} TEXT" for col in df.columns]
    create_table_sql = f"CREATE TABLE IF NOT EXISTS {table_name} ({', '.join(columns)})"
    conn.execute(create_table_sql)

def main():
    engine = create_engine(f"sqlite:///{SQLITE_DB}")
    conn = sqlite3.connect(SQLITE_DB)

    for table, variables in TABLES.items():
        print(f"Fetching data for table {table}...")
        df = fetch_census_data(table, variables)
        
        if df is not None:
            print(f"Creating table and uploading data for {table} to SQLite...")
            table_name = table.lower()
            create_table(conn, table_name, df)
            df.to_sql(table_name, engine, if_exists='replace', index=False)
            print(f"Table {table} created and data uploaded successfully.")
        
    conn.close()
    print("Data fetching and uploading to SQLite complete.")

if __name__ == "__main__":
    main()

*********************** All Segments **********************************
import requests
import pandas as pd
import sqlite3
from sqlalchemy import create_engine
import time

# Configuration
API_KEY = "YOUR_CENSUS_API_KEY"
BASE_URL = "https://api.census.gov/data"
YEAR = "2020"
DATASET = "dec/pl"
SQLITE_DB = "census_data.db"

# Updated list of tables and their variables
TABLES = {
    "P1": ["P1_001N"],  # Total Population
    "P2": ["P2_001N", "P2_002N", "P2_003N"],  # Hispanic or Latino, and Not Hispanic or Latino
    "P3": ["P3_001N", "P3_002N", "P3_003N", "P3_004N", "P3_005N", "P3_006N", "P3_007N"],  # Race
    "P4": ["P4_001N", "P4_002N", "P4_003N"],  # Hispanic or Latino, and Race
    "P5": ["P5_001N", "P5_002N", "P5_003N", "P5_004N", "P5_005N", "P5_006N", "P5_007N", "P5_008N", "P5_009N", "P5_010N"],  # Group Quarters Population
    "H1": ["H1_001N"],  # Total Housing Units
    "GEO": ["NAME", "state", "county", "tract", "block"]  # Geographic identifiers
}

def fetch_census_data(table, variables):
    url = f"{BASE_URL}/{YEAR}/{DATASET}"
    params = {
        "get": ",".join(variables + ([] if table == "GEO" else ["NAME"])),
        "for": "tract:*" if table != "GEO" else "state:*",
        "in": "state:*" if table != "GEO" else "",
        "key": API_KEY
    }
    
    for attempt in range(3):  # Try up to 3 times
        try:
            response = requests.get(url, params=params)
            response.raise_for_status()  # Raises an HTTPError for bad responses
            data = response.json()
            df = pd.DataFrame(data[1:], columns=data[0])
            return df
        except requests.exceptions.RequestException as e:
            print(f"Error fetching data for table {table} (Attempt {attempt + 1}): {e}")
            print(f"URL: {response.url}")
            print(f"Response content: {response.text}")
            if attempt < 2:
                print("Retrying in 5 seconds...")
                time.sleep(5)
            else:
                print("Max retries reached. Moving to next table.")
                return None

def create_table(conn, table_name, df):
    columns = [f"{col} TEXT" for col in df.columns]
    create_table_sql = f"CREATE TABLE IF NOT EXISTS {table_name} ({', '.join(columns)})"
    conn.execute(create_table_sql)

def main():
    engine = create_engine(f"sqlite:///{SQLITE_DB}")
    conn = sqlite3.connect(SQLITE_DB)

    for table, variables in TABLES.items():
        print(f"Fetching data for table {table}...")
        df = fetch_census_data(table, variables)
        
        if df is not None:
            print(f"Creating table and uploading data for {table} to SQLite...")
            table_name = table.lower()
            create_table(conn, table_name, df)
            df.to_sql(table_name, engine, if_exists='replace', index=False)
            print(f"Table {table} created and data uploaded successfully.")
        
    conn.close()
    print("Data fetching and uploading to SQLite complete.")

if __name__ == "__main__":
    main()
*********************** *******************************************

import requests
import pandas as pd
import sqlite3

# Step 1: Define your Census API key
API_KEY = 'your_api_key_here'  # Replace with your actual Census API key

# Step 2: Define the Census API endpoint and parameters
BASE_URL = 'https://api.census.gov/data/2020/acs/acs5'
PARAMS = {
    'get': 'NAME,B01001_001E',  # Example: Get NAME (Geography) and Total Population (B01001_001E)
    'for': 'state:*',            # Example: Pull data for all states
    'key': API_KEY
}

# Step 3: Make the GET request to the Census API
response = requests.get(BASE_URL, params=PARAMS)

# Step 4: Check if the request was successful
if response.status_code == 200:
    # Convert the response to a pandas DataFrame
    data = response.json()
    df = pd.DataFrame(data[1:], columns=data[0])
    
    # Print the first few rows of the DataFrame to verify data
    print(df.head())
    
    # Step 5: Connect to SQLite Database (or create it)
    conn = sqlite3.connect('census_data.db')
    cursor = conn.cursor()
    
    # Step 6: Create a table based on DataFrame columns
    table_name = 'census_data'
    columns = ', '.join([f'{col} TEXT' for col in df.columns])  # Assuming all data is text
    create_table_query = f"CREATE TABLE IF NOT EXISTS {table_name} ({columns});"
    cursor.execute(create_table_query)
    
    # Step 7: Insert data into the SQLite table
    placeholders = ', '.join(['?'] * len(df.columns))
    insert_query = f"INSERT INTO {table_name} VALUES ({placeholders})"
    cursor.executemany(insert_query, df.values.tolist())
    
    # Commit the transaction and close the connection
    conn.commit()
    conn.close()
    
    print(f"Data successfully saved to {table_name} table in census_data.db SQLite database.")
else:
    print(f"Error: {response.status_code}")
************************ V5 *************************************

import requests
import pandas as pd
import sqlite3

# Define your Census API key
API_KEY = 'your_api_key_here'  # Replace with your actual Census API key

# Connect to SQLite Database (or PostgreSQL for production)
conn = sqlite3.connect('census_data.db')
cursor = conn.cursor()

# Function to create tables similar to ACS/2010 Census structure
def create_structured_table(table_name, columns):
    column_definitions = ', '.join([f"{col} TEXT" for col in columns])
    create_query = f"CREATE TABLE IF NOT EXISTS {table_name} ({column_definitions});"
    cursor.execute(create_query)
    print(f"Table {table_name} created or verified.")

# Function to populate the table with data pulled from Census API
def populate_table_from_api(table_name, columns, api_params):
    BASE_URL = 'https://api.census.gov/data/2020/acs/acs5'
    api_params['key'] = API_KEY
    response = requests.get(BASE_URL, params=api_params)
    
    if response.status_code == 200:
        data = response.json()
        df = pd.DataFrame(data[1:], columns=data[0])
        placeholders = ', '.join(['?'] * len(df.columns))
        insert_query = f"INSERT INTO {table_name} VALUES ({placeholders})"
        cursor.executemany(insert_query, df.values.tolist())
        conn.commit()
        print(f"Data populated into {table_name}.")
    else:
        print(f"Error fetching data: {response.status_code}")

# Function to streamline request process for new variables
def add_new_variable_to_table(table_name, new_variable):
    add_column_query = f"ALTER TABLE {table_name} ADD COLUMN {new_variable} TEXT;"
    cursor.execute(add_column_query)
    print(f"Column {new_variable} added to {table_name}.")

# Function to handle geographical level decisions
def handle_geography(table_name, geography_level):
    # Implement logic to retain or aggregate geographic data based on level
    print(f"Handling geography level {geography_level} for {table_name}.")

# Example usage
# 1. Structure Data (BRFSS similar to ACS/2010 Census)
columns_brfss = ['NAME', 'B01001_001E', 'B02001_002E']  # Example columns, customize as needed
create_structured_table('BRFSS_2020', columns_brfss)

# 2. Handle Specific Project Requests (CCP data or others)
# Example: Populate PCT1 table
api_params_pct1 = {
    'get': 'NAME,B01001_001E',
    'for': 'state:*'
}
populate_table_from_api('PCT1', columns_brfss, api_params_pct1)

# 3. Ensure Table Requests are Fulfilled
# Example: Ensure all necessary tables are created and populated
tables_to_ensure = ['PCT2', 'PCT3', 'H11']
for table in tables_to_ensure:
    create_structured_table(table, columns_brfss)
    populate_table_from_api(table, columns_brfss, api_params_pct1)  # Customize API params as needed

# 4. Streamline Request Process
add_new_variable_to_table('PCT1', 'New_Variable')

# 5. Handle Geographical Level Decisions
handle_geography('PCT1', 'tract')

# 6. Provide Clarity on PUMS Files and Geography
# Document or implement specific functions as needed

# Close the connection
conn.close()
******************* v6 **************************

import requests
import pandas as pd
import sqlite3

# Define your Census API key
API_KEY = 'your_api_key_here'  # Replace with your actual Census API key

# Connect to SQLite Database (or PostgreSQL for production)
conn = sqlite3.connect('census_data.db')
cursor = conn.cursor()

# Function to create tables similar to ACS/2010 Census structure
def create_structured_table(table_name, columns):
    column_definitions = ', '.join([f"{col} TEXT" for col in columns])
    create_query = f"CREATE TABLE IF NOT EXISTS {table_name} ({column_definitions});"
    cursor.execute(create_query)
    print(f"Table {table_name} created or verified.")

# Function to populate the table with data pulled from Census API
def populate_table_from_api(table_name, columns, api_params):
    BASE_URL = 'https://api.census.gov/data/2020/acs/acs5'
    api_params['key'] = API_KEY
    response = requests.get(BASE_URL, params=api_params)
    
    if response.status_code == 200:
        data = response.json()
        df = pd.DataFrame(data[1:], columns=data[0])
        
        # Check if the table exists before attempting to insert data
        cursor.execute(f"SELECT name FROM sqlite_master WHERE type='table' AND name='{table_name}';")
        if cursor.fetchone() is None:
            print(f"Error: Table {table_name} does not exist.")
            return
        
        placeholders = ', '.join(['?'] * len(df.columns))
        insert_query = f"INSERT INTO {table_name} VALUES ({placeholders})"
        cursor.executemany(insert_query, df.values.tolist())
        conn.commit()
        print(f"Data populated into {table_name}.")
    else:
        print(f"Error fetching data: {response.status_code}")

# Ensure table is created before population
columns_brfss = ['NAME', 'B01001_001E', 'B02001_002E']  # Example columns, customize as needed
create_structured_table('PCT1', columns_brfss)

# Now populate the table with data
api_params_pct1 = {
    'get': 'NAME,B01001_001E',
    'for': 'state:*'
}
populate_table_from_api('PCT1', columns_brfss, api_params_pct1)

# Close the connection
conn.close()
