from pyspark.sql import SparkSession
import logging
import time
import threading
import json

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Create widgets for user input
dbutils.widgets.removeAll()
dbutils.widgets.text("source_table", "", "Source Table")
dbutils.widgets.text("target_table", "", "Target Table")
dbutils.widgets.dropdown("truncate", "no", ["yes", "no"], "Truncate Target Table")
dbutils.widgets.text("elapsed_time", "0", "Elapsed Time (seconds)")

# Function to get all widget values
def get_widget_values():
    return {
        "source_table": dbutils.widgets.get("source_table"),
        "target_table": dbutils.widgets.get("target_table"),
        "truncate": dbutils.widgets.get("truncate"),
        "elapsed_time": dbutils.widgets.get("elapsed_time")
    }

# HTML template
html_template = """
<div id="ingestionUI">
    <h3>Ingestion Process</h3>
    <b>Source Table:</b> <span id="sourceTable"></span><br>
    <b>Target Table:</b> <span id="targetTable"></span><br>
    <b>Truncate:</b> <span id="truncate"></span><br>
    <b>Elapsed Time:</b> <span id="elapsedTime"></span> seconds
</div>

<script>
var widgetValues = {widget_values};

function updateUI() {{
    document.getElementById('sourceTable').textContent = widgetValues.source_table;
    document.getElementById('targetTable').textContent = widgetValues.target_table;
    document.getElementById('truncate').textContent = widgetValues.truncate;
    document.getElementById('elapsedTime').textContent = widgetValues.elapsed_time;
    
    // Make elapsed time input read-only
    var elapsedTimeInput = document.querySelector('input[title="Elapsed Time (seconds)"]');
    if (elapsedTimeInput) {{
        elapsedTimeInput.readOnly = true;
        elapsedTimeInput.style.backgroundColor = "#f0f0f0";
    }}
}}

updateUI();

// Set up interval to update UI every second
setInterval(function() {{
    fetch('/api/2.0/workspace/runner/run', {{
        method: 'POST',
        headers: {{ 'Content-Type': 'application/json' }},
        body: JSON.stringify({{
            commandString: 'print(json.dumps(get_widget_values()))',
            language: 'python',
            clusterId: "{cluster_id}"
        }})
    }})
    .then(response => response.json())
    .then(data => {{
        if (data.results && data.results.resultType === 'text') {{
            widgetValues = JSON.parse(data.results.data);
            updateUI();
        }}
    }});
}}, 1000);
</script>
"""

# Get the current cluster ID
clusterId = spark.conf.get("spark.databricks.clusterUsageTags.clusterId")

# Display the HTML
displayHTML(html_template.format(
    widget_values=json.dumps(get_widget_values()),
    cluster_id=clusterId
))

def update_timer(stop_event):
    start_time = time.time()
    while not stop_event.is_set():
        elapsed_time = int(time.time() - start_time)
        dbutils.widgets.text("elapsed_time", str(elapsed_time))
        time.sleep(1)

def ingest_data(source_table, target_table, truncate='no'):
    logger.info(f"Starting ingestion process from {source_table} to {target_table}")
    start_time = time.time()
    
    stop_event = threading.Event()
    timer_thread = threading.Thread(target=update_timer, args=(stop_event,))
    timer_thread.start()
    
    try:
        # Create SparkSession
        spark = SparkSession.builder.appName("IngestData").getOrCreate()
        logger.info("SparkSession created successfully")

        # Read source table
        df = spark.table(source_table)
        logger.info(f"Source table '{source_table}' read successfully")

        # Write to target table
        if truncate.lower() == 'yes':
            logger.info(f"Overwriting target table '{target_table}'")
            df.write.mode("overwrite").saveAsTable(target_table)
        else:
            logger.info(f"Appending to target table '{target_table}'")
            df.write.mode("append").saveAsTable(target_table)

        # Log some statistics
        row_count = df.count()
        end_time = time.time()
        duration = end_time - start_time
        
        logger.info(f"Data ingestion complete. {row_count} rows from {source_table} have been written to {target_table}")
        logger.info(f"Ingestion process took {duration:.2f} seconds")

        return True, f"Successfully ingested {row_count} rows in {duration:.2f} seconds"

    except Exception as e:
        end_time = time.time()
        duration = end_time - start_time
        error_message = f"An error occurred during ingestion after {duration:.2f} seconds: {str(e)}"
        logger.error(error_message, exc_info=True)
        return False, error_message
    finally:
        stop_event.set()
        timer_thread.join()

# Main execution
source_table = dbutils.widgets.get("source_table")
target_table = dbutils.widgets.get("target_table")
truncate = dbutils.widgets.get("truncate")

# Validate inputs
if not all([source_table, target_table]):
    print("Error: Both Source Table and Target Table fields must be filled.")
else:
    # Execute the ingestion function
    success, message = ingest_data(source_table, target_table, truncate)
    
    if success:
        print("Ingestion process completed successfully!")
        print(message)
    else:
        print("Ingestion process failed.")
        print(message)

# Clear the elapsed time after completion
dbutils.widgets.remove("elapsed_time")
